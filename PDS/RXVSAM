  TITLE 'RXVSAM - REXX Function To Perform VSAM Requests'
         PUSH  PRINT
         PRINT OFF
         MACRO
&LABEL   GENMSGS &GEN=DSECT
         AIF   ('&GEN' EQ 'DSECT').OK
         AIF   ('&GEN' EQ 'CSECT').OK
         MNOTE 8,'GENMSGS MACRO STATEMENT HAD AN INVALID VALUE'
         AGO   .ENDMAC
.OK      ANOP
&LABEL   &GEN
         AIF   ('&GEN' EQ 'CSECT').SKP0000
M$ALLOK  DS      0CL38
.SKP0000 ANOP
         DC      CL4'0000'
         DC      CL4'I'
         DC      CL30'Request successfully processed'
         AIF   ('&GEN' EQ 'CSECT').SKP0001
M$BADARG DS      0CL31
.SKP0001 ANOP
         DC      CL4'0001'
         DC      CL4'E'
         DC      CL23'Invalid argument passed'
         AIF   ('&GEN' EQ 'CSECT').SKP0002
M$BADOPN DS      0CL19
.SKP0002 ANOP
         DC      CL4'0002'
         DC      CL4'E'
         DC      CL11'Open failed'
         AIF   ('&GEN' EQ 'CSECT').SKP0003
M$BADCLO DS      0CL20
.SKP0003 ANOP
         DC      CL4'0003'
         DC      CL4'E'
         DC      CL12'Close failed'
         AIF   ('&GEN' EQ 'CSECT').SKP0004
M$EOF    DS      0CL19
.SKP0004 ANOP
         DC      CL4'0004'
         DC      CL4'W'
         DC      CL11'End of File'
         AIF   ('&GEN' EQ 'CSECT').SKP0005
M$PREVOP DS      0CL28
.SKP0005 ANOP
         DC      CL4'0005'
         DC      CL4'E'
         DC      CL20'File is already open'
         AIF   ('&GEN' EQ 'CSECT').SKP0006
M$NOBLK  DS      0CL46
.SKP0006 ANOP
         DC      CL4'0006'
         DC      CL4'E'
         DC      CL38'Unable to access RXVSAM BLOCK variable'
         AIF   ('&GEN' EQ 'CSECT').SKP0007
M$NORECV DS      0CL67
.SKP0007 ANOP
         DC      CL4'0007'
         DC      CL4'E'
         DC      CL46'REXX record variable could not be accessed or '
         DC      CL13'was undefined'
         AIF   ('&GEN' EQ 'CSECT').SKP0008
M$DUPL   DS      0CL24
.SKP0008 ANOP
         DC      CL4'0008'
         DC      CL4'E'
         DC      CL16'Duplicate record'
         AIF   ('&GEN' EQ 'CSECT').SKP0010
M$VMSG   DS      0CL38
.SKP0010 ANOP
         DC      CL4'0010'
         DC      CL4'E'
         DC      CL30'Unable to save VSAM error data'
         AIF   ('&GEN' EQ 'CSECT').SKP0011
M$RMSG   DS      0CL41
.SKP0011 ANOP
         DC      CL4'0011'
         DC      CL4'E'
         DC      CL33'Unable to set return message text'
         AIF   ('&GEN' EQ 'CSECT').SKP0012
M$CLOSAC DS      0CL77
.SKP0012 ANOP
         DC      CL4'0012'
         DC      CL4'E'
         DC      CL46'ACB was not available to perform CLOSE request'
         DC      CL23' - file may not be open'
         AIF   ('&GEN' EQ 'CSECT').SKP0014
M$NOACB  DS      0CL71
.SKP0014 ANOP
         DC      CL4'0014'
         DC      CL4'E'
         DC      CL41'ACB was not available to perform request '
         DC      CL22'- file may not be open'
         AIF   ('&GEN' EQ 'CSECT').SKP0015
M$BADSCB DS      0CL56
.SKP0015 ANOP
         DC      CL4'0015'
         DC      CL4'E'
         DC      CL48'Unable to obtain max record length for this file'
         AIF   ('&GEN' EQ 'CSECT').SKP0016
M$NOTFND DS      0CL24
.SKP0016 ANOP
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL16'Record not found'
         AIF   ('&GEN' EQ 'CSECT').SKP016A
M$BWDNF  DS      0CL87
.SKP016A ANOP
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL47'Record not found - a FULL KEY must be specified'
         DC      CL32' when issuing a STARTBWD request'
         AIF   ('&GEN' EQ 'CSECT').SKP0017
M$NORLEN DS      0CL41
.SKP0017 ANOP
         DC      CL4'0017'
         DC      CL4'E'
         DC      CL33'Cannot determine length of record'
         AIF   ('&GEN' EQ 'CSECT').SKP0018
M$BADUPD DS      0CL41
.SKP0018 ANOP
         DC      CL4'0018'
         DC      CL4'E'
         DC      CL33'Unable to modify RPL for "UPDate"'
         AIF   ('&GEN' EQ 'CSECT').SKP0019
M$BADFUN DS      0CL23
.SKP0019 ANOP
         DC      CL4'0019'
         DC      CL4'E'
         DC      CL15'Function failed'
         AIF   ('&GEN' EQ 'CSECT').SKP0020
M$NOREC  DS      0CL40
.SKP0020 ANOP
         DC      CL4'0020'
         DC      CL4'E'
         DC      CL32'Unable to update RECORD variable'
         AIF   ('&GEN' EQ 'CSECT').SKP0021
M$NOIN   DS      0CL34
.SKP0021 ANOP
         DC      CL4'0021'
         DC      CL4'E'
         DC      CL26'File is not open for INPUT'
         AIF   ('&GEN' EQ 'CSECT').SKP0022
M$NOOUT  DS      0CL35
.SKP0022 ANOP
         DC      CL4'0022'
         DC      CL4'E'
         DC      CL26'File is not open for OUTPUT'
         AIF   ('&GEN' EQ 'CSECT').SKP0023
M$BADDSW DS      0CL42
.SKP0023 ANOP
         DC      CL4'0023'
         DC      CL4'E'
         DC      CL34'Unable to switch to DIR processing'
         AIF   ('&GEN' EQ 'CSECT').SKP0024
M$NOGEN  DS      0CL41
.SKP0024 ANOP
         DC      CL4'0024'
         DC      CL4'E'
         DC      CL33'READGENERIC only allowed for KSDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0025
M$NONNUM DS      0CL45
.SKP0025 ANOP
         DC      CL4'0025'
         DC      CL4'E'
         DC      CL37'Non-numeric key specified for an RRDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0026
M$NOESDS DS      0CL48
.SKP0026 ANOP
         DC      CL4'0026'
         DC      CL4'E'
         DC      CL40'This function is not allowed for an ESDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0027
M$NORRN  DS      0CL33
.SKP0027 ANOP
         DC      CL4'0027'
         DC      CL4'E'
         DC      CL25'Unable to set RXVSAM_RRN#'
         AIF   ('&GEN' EQ 'CSECT').SKP0028
M$KEYZER DS      0CL63
.SKP0028 ANOP
         DC      CL4'0028'
         DC      CL4'E'
         DC      CL48'A zero length (omitted) key is only allowed for '
         DC      CL7'an ESDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0088
M$NOPOS  DS      0CL55
.SKP0088 ANOP
         DC      CL4'0088'
         DC      CL4'E'
         DC      CL47'READPREV attempted without a previous STARTBWD '
         AIF   ('&GEN' EQ 'CSECT').SKP0092
M$NOGET  DS      0CL59
.SKP0092 ANOP
         DC      CL4'0092'
         DC      CL4'E'
         DC      CL47'REWRITE or DELETE attempted without a previous '
         DC      CL4'READ'
         AIF   ('&GEN' EQ 'CSECT').SKP0108
M$BADRL  DS      0CL99
.SKP0108 ANOP
         DC      CL4'0108'
         DC      CL4'E'
         DC      CL48'Record length = 0, > max, < key length (KSDS) or'
         DC      CL43' not equal to slot size (fixed length RRDS)'
.ENDMAC  ANOP
         MEND
*        POP PRINT                HIDE MACRO SOURCE, NOT NEEDED    @PJF
         MACRO
&LABEL   SETMSG &MSG=
         AIF   ('&MSG' NE '').OK
         MNOTE 8,'NO MESSAGE SPECIFIED'
         AGO   .ENDMAC
.OK      ANOP
         L     14,RXVSMSG@        GET EPA FOR RXVSAM MSG CSECT
         USING MSGDSECT,14
         LA    15,&MSG
         ST    15,MSG@            SAVE -> MESSAGE TEXT
         LA    15,L'&MSG
         STH   15,MSGLEN          SAVE MESSAGE LENGTH
         DROP  14
.ENDMAC  ANOP
         MEND
         SPACE
         MACRO
&LABEL   NTERROR &REQ=,&SYM=,&GOTO=
         AIF   ('&REQ' NE '').CHKSYM
         MNOTE 8,'NO REQUEST TYPE SPECIFIED'
         AGO   .ENDMAC
.CHKSYM  ANOP
         AIF   ('&SYM' NE '').OK
         MNOTE 8,'NO SYMBOL (LABEL) SPECIFIED'
         AGO   .ENDMAC
.OK      ANOP
         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT MESSAGE AREA
         ST    R15,NAMTOKRC                SAVE RETURN CODE
         CVD   R15,DBLWRK
         OI    BYTEWRK2,X'F0'
         MVC   NTMSGR15,HALFWRK2
         MVC   NTREQ,=CL8'&REQ'            SAVE REQUEST TYPE
         MVC   NTLABEL,=CL8'&SYM'          AND RXVSAM LABEL
         AIF   ('&GOTO' EQ '').ENDMAC
         J     &GOTO                                               @PJF
.ENDMAC  ANOP
         MEND
         EJECT
         MACRO
&LABEL   ADDTRACE &ENTRY=
         OC    TRACE@B,TRACE@B             DO WE HAVE A TRACE AREA?
         JNZ   YY&SYSNDX                   YES, ADD ENTRY TO IT    @PJF
         STORAGE OBTAIN,LENGTH=4096000     NO GET A 4 MEG AREA
         ST    R1,TRACE@B                  SAVE BEGINNING ADDR
         LR    R0,R1                       CLEAR AREA
         L     R1,=F'4096000'
         SR    R15,R15
         MVCL  R0,R14
         L     R1,TRACE@B                  GET -> TO AREA
         MVC   0(8,R1),=CL8'TR@CET@B'      STICK EYECATCHER IN IT
         LA    R15,8(,R1)                                          @PJF
         ST    R15,TRACE@C                 POSITION FOR NEXT ENTRY
         LR    R15,R1
         A     R15,=F'4096000'
         ST    R15,TRACE@M                 ENDING ADDRESS OF AREA
YY&SYSNDX  L   R1,TRACE@C
         LA    R15,L'&ENTRY                MAKE SURE THIS ENTRY
         AR    R15,R1                      WON'T GO OFF THE END
         C     R15,TRACE@M
         JNL   ZZ&SYSNDX                                           @PJF
         MVC   0(L'&ENTRY,R1),&ENTRY
         ST    R15,TRACE@C
ZZ&SYSNDX  DS  0H
         MEND
         COPY  IEABRC                                              @PJF
         POP   PRINT                                               @PJF
         EJECT
*---------------------------------------------------------------------
*  This function will provide access to a VSAM file from a REXX exec.
* It is designed to be called as an external function in the MVS/ESA
* environment.  The function call should take the form:
*    RXVSAM(<request>,<ddname>,{<key>|<filetype>,<recordarea>})
* The first 2 arguments are required, 3 and 4 are optional.  Argument
* definitions/values:
*  1. request: OPENINPUT OPENOUTPUT OPENIO
*              CLOSE
*              READ READGENERIC READNEXT READPREV READLAST
*              WRITE REWRITE DELETE
*              STARTFWD STARTBWD
*  2. ddname: must be 1 - 8 uppercase or national characters
*  3. key: the key or RRN or RBA (for requests other than OPEN)    @PJF
*     filetype: either KSDS, ESDS or RRDS (one of the three must be
*               specified in uppercase for OPEN requests)
*     This argument may be null in some cases (READNEXT, READPREV,
*     READLAST, WRITE, DELETE).  A null key for WRITE requests
*     is designed for use in writing to an RRDS for the first time
*     (initialization), and should always be used when writing to
*     an ESDS.  To make the argument 3 null, code an extra comma
*     before argument 4, for example:
*         result = RXVSAM('READNEXT','MYFILE',,'MY_RECORD_AREA')
*     If the key is an RRN or RBA, it must be given in decimal.    @PJF
*     Direct READs are possible for an ESDS, using RBAs as the key.@PJF
*  4. recordarea: the REXX VARIABLE name that contains record data
*     this argument is always ignored for OPEN or CLOSE requests.
*     If this argument is omitted, the variable name RXVSAM_RECORD is
*     used (for READ requests) or assumed (for WRITE|REWRITE requets).
*
*  2.1 -- add DELETE macros for routines that have been LOADed
*  (IRXEXCOM and various name / token routines).
*
*  2.2 -- locate IEANTxx services by bumping through storage rather
*  than doing a LOAD. Remove associated DELETEs. Add RXVSAMSG CSECT
*  at end of this assembly; revise GENMSGS macro. Get IRXEXCOM address
*  by bumping thru ENVBLOCK (environemnt block) to IRXEXTE (external
*  address table), rather than doing a LOAD. Remove associated DELETE.
*  Add required ENVBLOCK & IRXEXTE macros (dsects). Allow rewrite for
*  an ESDS. (Special thanks to Rob Van Riel for these changes)
*
*  2.3 -- Convert to baseless programming (J not B, JNE not BNE,   @PJF
*  etc.).  Added SYSTATE ARCHLVL=2 and COPY IEABRC and             @PJF
*  CALL ...,LINKINST=BASR in support of baseless structure.        @PJF
*  R12 now points to label CONSTANT for LTORG and true constants,  @PJF
*  R11 and R10 are no longer used for any purpose.                 @PJF
*  Executed instructions moved to CONSTANT section for             @PJF
*  addressibility.   Hardware pipeline delays may result from this @PJF
*  due to executed instruction not being in the instruction cache. @PJF
*  Now allows both STARTFWD and STARTBWD for ESDS files.           @PJF
*  HLASM system variable &SYSDATC used instead of &SYSDATE for     @PJF
*  eyecatcher constant.                                            @PJF
*  LA and ST instructions using explicit displ(indexreg) for their @PJF
*  second argument changed to use displ(,basereg) format to avoid  @PJF
*  unnecessary index register activity.                            @PJF
*  SAVE macro added with eyecatcher string to both preserve the    @PJF
*  savearea chain and to use standard eyecatcher placement for     @PJF
*  module identification.  BAKR and PR are still used to perform   @PJF
*  entry and exit from module.                                     @PJF
*  Corrected roundup of record length to next doubleword at label  @PJF
*  OPEN310.                                                        @PJF
*  IHASTCB macro used to map STCB instead of hard-coded definition.@PJF
*  IFGACB and IFGRPL macros added for ACB and RPL mapping.         @PJF
*
*----------------------------------------------------------------------
         EJECT
         SYSSTATE ARCHLVL=2       ADDED TO USE RELATIVE BRANCHING  @PJF
RXVSAM   CSECT
RXVSAM   AMODE 31
RXVSAM   RMODE ANY
         SPACE
R0       EQU   0                  REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6                  -> SHVBLOCK (also used as a work reg)
R7       EQU   7                  -> FILE WORK AREA
R8       EQU   8                  -> ARGUMENT LIST
R9       EQU   9                  -> LOCAL WORK AREA
R10      EQU   10                                                  @PJF
R11      EQU   11                                                  @PJF
R12      EQU   12                 BASE for CONSTANT area only      @PJF
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
MSGDSECT GENMSGS GEN=DSECT
         SPACE 2
         IEANTASM
*        PRINT NOGEN              I LIKE SEEING ALL GENERATED CODE @PJF
         EJECT
RXVSAM   CSECT ,                  RESUME CSECT
         SPACE
*        SAVE REGS IN THE STD WAY TO PRESERVE THE SAVEAREA CHAIN   @PJF
         SAVE  (14,12),,'RXVSAM  ,&SYSDATC,&SYSTIME,RELEASE 2.3'   @PJF
*        BAKR AND PR ACTUALLY USED FOR REGISTER SAVE AND RETURN    @PJF
         BAKR  R14,0              SAVE CALLER'S REGS & RETURN LOC
         LARL  R12,CONSTANT       ADDRESS FOR LTORG+CONSTANT AREA  @PJF
         USING CONSTANT,R12       AND TELL ASSEMBLER ABOUT IT      @PJF
         LR    R4,R1              PARK PARM POINTER (R1) IN R4
         LR    R5,R0              PARK ENV BLOCK PTR (R0) IN R5    @ANZ
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE OBTAIN,LENGTH=(R2)    GET LOCAL WORK AREA
         SPACE
         LR    R9,R1              SET BASE REGISTER FOR LOCAL WORK AREA
         USING LOCAL_WORKAREA,R9  SET ADDRESSABILITY
         LR    R2,R9
         LA    R3,LOCAL_WORKAREA_LENGTH
         SR    R15,R15            PAD OF X'00' & ZERO LENGTH
         MVCL  R2,R14             INIT WORKAREA TO BINARY ZERO
         LA    R15,SAVEAREA       SET -> TO OUR SAVE AREA
         ST    R13,4(,R15)        CHAIN BACKWARD ->                @PJF
         ST    R15,8(,R13)        CHAIN FORWARD ->                 @PJF
         LR    R13,R15
         EJECT
MAIN100  DS    0H
         IAZXJSAB READ,JOBID=MYJOBID
         SPACE
         LR    R1,R4              RESTORE PARM (R1) FROM SAVED REG
         USING EFPL,R1            SET ADDRESSABILITY
         ST    R1,EFPL@           KEEP POINTER AROUND JUST IN CASE
         LA    R6,OURSHVBL        INIT -> TO OUR SHARED VAR BLK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         L     R8,EFPLARG         GET -> TO ARGUMENT LIST
         USING ARGTABLE_ENTRY,R8  SET ADDRESSABILITY
         DROP  R1                 DROP EFPL ADDRESSABILITY
         SPACE
         MVC   VSAMEMSG(VMSGLEN),VMSGINIT  INIT VSAM ERROR MSG AREA
         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT NAME/TOKEN MSG AREA
         SPACE
         SETMSG MSG=M$ALLOK       INITIALIZE RETURN MESSAGE
         MVC   VSAMER15,=CL2'00'  INITIALIZE VSAM REG 15 RC
         SPACE
*R5 already -> environment block -- loaded from R0 at entry to RXVSAM
         SPACE
         USING ENVBLOCK,R5        SET ADDRESSABILITY TO ENVBLOCK   @ANZ
         ST    R5,ENVB@           SAVE ENVIRONMENT BLOCK POINTER   @ANZ
         L     R5,ENVBLOCK_IRXEXTE EXTERNAL ENTRY VECTOR ADDRESS   @ANZ
         USING IRXEXTE,R5         SET ADDRESSABILITY TO EXTE       @ANZ
         L     R0,IRXEXCOM        IRXEXCOM ROUTINE ADDRESS         @ANZ
         ST    R0,IRXEXCO@        SAVE ROUTINE ADDRESS FOR LATER USE
         DROP  R5                 DROP ENVBLOCK ADDRESSABILITY     @ANZ
         SPACE
         L     R5,ARGTABLE_ARGSTRING_PTR  GET ADDR OF REQUEST ARG
         C     R5,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'
         JE    MAIN400            NO ARG PASSED,ERROR              @PJF
         SPACE
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT (DDNAME)
         LM    R3,R4,ARGTABLE_ARGSTRING_PTR  GET ADDR & LENGTH OF ARG
         C     R3,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'
         JE    MAIN400            NO ARG PASSED,ERROR              @PJF
         SPACE
         CH    R4,=H'8'           IF DDNAME LONGER THAN 8 CHARACTERS
         JH    MAIN400            IT'S AN ERROR                    @PJF
         LA    R8,ARGTABLE_NEXT   BUMP TO "NEXT" ARGUMENT
         SPACE
         MVC   DDNAME,SPACES      INIT BLANK PADDED DDNAME
         BCTR  R4,0               DECR IN PREPARATION FOR EXECUTED MVC
         EX    R4,MOVEDDNM        SET OUR COPY OF THE DDNAME
         SPACE
         MVC   IEANTNA1,MYJOBID   CREATE "NAME" FOR NAME / TOKEN
         MVI   IEANTNA1,C'X'      SERVICES: JOBID (1ST CHAR ALWAYS "X")
         MVC   IEANTNA2,DDNAME    PLUS DDNAME
         XC    IEANTTOK,IEANTTOK  CLEAR OUT "TOKEN"
         MVC   IEANTLVL,=AL4(IEANT_TASK_LEVEL)  TASK LVL FOR ALL REQ
         EJECT
MAIN200  DS    0H
*
* THE FOLLOWING USING IS GLOBAL (FOR THE REST OF THE CSECT).  IT IS THE
* INDIVIDUAL ROUTINE'S RESPONSIBILITY TO ENSURE R7 CONTAINS A VALID
* ADDRESS WHEN A FILE WORK AREA IS "ACTIVE"
*
         USING FWABLOCK,R7
*
* PERFORM CORRECT ROUTINE BASED ON FUNCTION REQUEST - SET R14 AS A
* "RETURN" ADDRESS
*
         LARL  R14,MAIN500        SERVES AS A "RETURN" POINT       @PJF
         CLC   =CL4'OPEN',0(R5)
         JE    OPEN000                                             @PJF
         CLC   =CL4'CLOS',0(R5)
         JE    CLOS000                                             @PJF
         CLC   =CL4'READ',0(R5)
         JE    READ000                                             @PJF
         CLC   =CL4'WRIT',0(R5)
         JE    WRIT000                                             @PJF
         CLC   =CL4'REWR',0(R5)
         JE    REWR000                                             @PJF
         CLC   =CL4'DELE',0(R5)
         JE    DELE000                                             @PJF
         CLC   =CL4'STAR',0(R5)
         JE    STAR000                                             @PJF
         SPACE
MAIN400  DS    0H
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         J     MAIN900            EXIT                             @PJF
         EJECT
MAIN500  DS    0H
         SPACE
*+*+*+
*  NEED TO CHECK FOR AN INVALID NAME / TOKEN REQUEST & PUT ERROR
*  MESSAGE IN A REXX VARIABLE IF NECESSARY
*+*+
         LA    R2,VMSGVAR         ELSE, SET MESSAGE: GET -> TO MESSAGE
         LA    R3,L'VMSGVAR       VARIABLE NAME & LENGTH OF VAR NAME
         STM   R2,R3,SHVNAMA      STORE IN SHV PARM LIST (2 FULLWORDS)
         CLC   VSAMER15,=CL2'00'  IS VSAM REG 15 RC ZERO?
         JE    MAIN520            YES, RESET VARIABLE TO ITS DEFAUL@PJF
         SPACE
         MVC   SHVVALL,=A(VSAMELEN)   ELSE, SET IT TO OUR "REAL"
         LA    R0,VSAMEMSG        VARIABLE
         ST    R0,SHVVALA
         J     MAIN530                                             @PJF
         SPACE
MAIN520  DS    0H
         SPACE
         MVC   SHVVALL,SHVNAML    NAME LENGTH & VAR LENGTH ARE EQUAL
         MVC   SHVVALA,SHVNAMA    NAME AND VALUE ARE THE SAME TOO
         SPACE
MAIN530  DS    0H
         SPACE
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       GET EPA TO IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX
               LINKINST=BASR                                       @PJF
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         JZ    MAIN900            IF ALL OK, CONTINUE              @PJF
         SPACE
         SETMSG MSG=M$VMSG        ELSE, SET MESSAGE THEN FALL THRU
         SPACE
MAIN900  DS    0H
         LA    R0,L'RMSGVAR       LENGTH OF RET MSG VARIABLE NAME
         ST    R0,SHVNAML         SET LENGTH IN SHARED VARIABLE BLOCK
         LA    R0,RMSGVAR         -> TO VARIABLE NAME
         ST    R0,SHVNAMA
         LH    R0,MSGLEN          LENGTH OF VARIABLE
         ST    R0,SHVVALL
         L     R0,MSG@            GET -> TO MESSAGE
         ST    R0,SHVVALA
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       ADDR OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX
               LINKINST=BASR                                       @PJF
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         JZ    MAIN950            IF ALL OK, CONTINUE              @PJF
         SPACE
         SETMSG MSG=M$RMSG        REVISE RETURN MESSAGE
         EJECT
MAIN950  DS    0H
         L     R1,EFPL@           GET POINTER TO ORIGINAL PARM LIST
         USING EFPL,R1            SET ADDRESSABILITY
         L     R2,EFPLEVAL        GET -> TO EVALUATION BLOCK
         L     R2,0(,R2)          GET ACTUAL ADDRESS OF BLOCK
         USING EVALBLOCK,R2       SET ADDRESSABILITY
         L     R14,MSG@           1ST 4 BYTES OF MSG ARE THE RESULT
         MVC   EVALBLOCK_EVLEN,=F'4'          PASS RESULT BACK IN THE
         MVC   EVALBLOCK_EVDATA(4),0(R14)     EVALUATION BLOCK
         DROP  R2,R1
         SPACE
GOBACK   DS    0H
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R9)    RELEASE WORK AREA
         SPACE
         SLR   R15,R15            MAKE SURE RETURN CODE IS ZERO
         PR                       RETURN TO CALLER
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
OPEN000  DS    0H
*
* UPON ENTRY, R8 -> ARGUMENT LIST 3 SLOT (FILE TYPE), R5 STILL -> TO
* TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         L     R4,ARGTABLE_ARGSTRING_PTR
         C     R4,=X'FFFFFFFF'    IS ADDRESS ALL X'FF' ?
         JNE   OPEN010            NO, CONTINUE                     @PJF
         SPACE
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         J     OPEN999                                             @PJF
         SPACE
OPEN010  DS    0H    -- SEE IF THERE'S A NAME / TOKEN FOR THIS FILE --
         BRAS  R14,RTRVTOK0
         SPACE
         CH    R15,=AL2(IEANT_NOT_FOUND)   IF NO TOKEN EXISTS
         JE    OPEN020                     IT'S OK TO CONTINUE     @PJF
         SPACE
         LTR   R15,R15                     IF A TOKEN EXISTS
         JZ    OPEN015                     FILE IS ALREADY OPEN    @PJF
         SPACE
         NTERROR REQ=RETRIEVE,SYM=OPEN010,GOTO=OPEN999
         SPACE
OPEN015  DS    0H
         SETMSG MSG=M$PREVOP
         J     OPEN999          THE FILE IS ALREADY OPEN - EXIT    @PJF
         SPACE
OPEN020  DS    0H
         LA    R2,FWALEN        LENGTH OF FILE WORK AREA
         STORAGE OBTAIN,LENGTH=(R2)    GET A NEW FILE WORK AREA
         SPACE
         LR    R7,R1            -> TO FWA (ADDRESSABILITY ALREADY SET)
         LR    R2,R7
         LA    R3,FWALEN
         SR    R15,R15
         MVCL  R2,R14           INIT AREA TO X'00'
*
* NOTE: R3 REMAINS AS A POINTER TO THE ACB THROUGHOUT THE REST OF THE
*       OPEN LOGIC
*
         LA    R3,FWAACB          -> TO OUR ACB
         EJECT
         CLC   =CL4'KSDS',0(R4)   KSDS?
         JNE   OPEN030            NO, TRY NEXT POSSIBLITY          @PJF
         SPACE
         OI    F@OPENFL,F@OSEQ+F@ODIR+F@OKSDS     SET OUR FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X
               LENGTH=FWAACBL,WAREA=(R3),RMODE31=ALL,                  X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         JZ    OPEN100            YES - CONTINUE                   @PJF
         J     OPEN900            NO - DO ERROR HANDLING           @PJF
         SPACE
OPEN030  DS    0H
         CLC   =CL4'ESDS',0(R4)   ESDS?
         JNE   OPEN040            NO, TRY NEXT POSSIBLITY          @PJF
         SPACE
         OI    F@OPENFL,F@OSEQ+F@OESDS          SET FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(ADR,SEQ),              X
               LENGTH=FWAACBL,WAREA=(R3),RMODE31=ALL,                  X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         JZ    OPEN100            YES - CONTINUE                   @PJF
         J     OPEN900            NO - DO ERROR HANDLING           @PJF
         SPACE
OPEN040  DS    0H
         CLC   =CL4'RRDS',0(R4)   RRDS?
         JNE   OPEN050            NO, DO ERROR PROCESSING          @PJF
         SPACE
         OI    F@OPENFL,F@OSEQ+F@ODIR+F@ORRDS         SET FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X
               LENGTH=FWAACBL,WAREA=(R3),RMODE31=ALL,                  X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         JZ    OPEN100            YES - CONTINUE                   @PJF
         J     OPEN900            NO - DO ERROR HANDLING           @PJF
         SPACE
OPEN050  DS    0H
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         J     OPEN999                                             @PJF
         EJECT
OPEN100  DS    0H
         CLC   =CL9'OPENINPUT',0(R5)    OPEN INPUT?
         JNE   OPEN110            NO, TRY NEXT POSSIBILITY         @PJF
         SPACE
         OI    F@OPENFL,F@OIN           SET FLAG
         MODCB ACB=(R3),MACRF=(IN),RMODE31=ALL,MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    OPEN200            YES - READY TO ISSUE OPEN        @PJF
         J     OPEN900            NO - DO ERROR HANDLING           @PJF
         SPACE
OPEN110  DS    0H
         CLC   =CL6'OPENIO',0(R5) INPUT & OUTPUT?
         JNE   OPEN120            NO, TRY NEXT POSSIBILITY         @PJF
         SPACE
         OI    F@OPENFL,F@OIN+F@OOUT    SET FLAGS
         MODCB ACB=(R3),MACRF=(IN,OUT),RMODE31=ALL,                    X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    OPEN200            YES - READY TO ISSUE OPEN        @PJF
         J     OPEN900            NO - DO ERROR HANDLING           @PJF
         EJECT
OPEN120  DS    0H
         CLC   =CL10'OPENOUTPUT',0(R5)   ONLY OUTPUT?
         JNE   OPEN130            NO, BAD ARGUMENT                 @PJF
         SPACE
         OI    F@OPENFL,F@OOUT           SET FLAG
         MODCB ACB=(R3),MACRF=(OUT),RMODE31=ALL,MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    OPEN200            YES - READY TO ISSUE OPEN        @PJF
         J     OPEN900            NO - DO ERROR HANDLING           @PJF
         SPACE
OPEN130  DS    0H
         SETMSG MSG=M$BADARG     SET BAD RESULT CODE
         J     OPEN999                                             @PJF
         EJECT
OPEN200  DS    0H
         XC    OPEN_PARMLIST,OPEN_PARMLIST   INIT AREA
         OI    OPEN_PARMLIST,X'80'           HI-ORDER ON = 31 BIT FORM
         ST    R3,OPEN_PARMLIST+4            STORE ACB -> IN 2ND WORD
         OPEN  MODE=31,MF=(E,OPEN_PARMLIST)  OPEN DATASET
         SPACE
         LTR   R15,R15            WAS OPEN SUCCESSFUL?
         JNZ   OPEN210            NO - DO ERROR PROCESSING         @PJF
         SPACE
         J     OPEN300            READY TO GENERATE RPL            @PJF
         SPACE
OPEN210  DS    0H
         MVC   VSAMELAB,=CL8'OPEN210'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         JZ    OPEN230            YES - GO PICK UP ERROR MESSAGE   @PJF
         SPACE
OPEN220  DS    0H
         MVC   VSAMELAB,=CL8'OPEN220'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         J     OPEN990            AND EXIT ROUTINE                 @PJF
         SPACE
OPEN230  DS    0H
         LH    R0,HALFWRK2
         CVD   R0,DBLWRK
         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE
         OI    VSAMEREA+3,X'F0'
         J     OPEN990            AND EXIT ROUTINE                 @PJF
         EJECT
OPEN300  DS    0H      -- GET MAX RECORD LENGTH & GENERATE RPL --
         LA    R2,F@LRECL
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,                           X
               FIELDS=LRECL,MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         JZ    OPEN310            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'OPEN300'
         MVC   VSAMEREA,=CL4'0000'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CH    R15,=H'4'          IF R15 ISN'T 4, REASON CODE ISN'T
         JNE   OPEN999            IN R0                            @PJF
         SPACE
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SETMSG MSG=M$BADSCB      SET BAD RESULT CODE
         SPACE
         J     OPEN999                                             @PJF
         SPACE
OPEN310  DS    0H
         L     R2,F@LRECL         GET MAX LRECL FROM SHOWCB
         LA    R2,7(,R2)          ROUND UP TO NEXT DOUBLEWORD      @PJF
         SRL   R2,3               DIVIDE BY 8, TRUNCATE REMAINDER  @PJF
         SLL   R2,3               MULTIPLY BY 8                    @PJF
         ST    R2,F@BUFLEN        SAVE LENGTH FOR LATER USE
         STORAGE OBTAIN,LENGTH=(R2)
         SPACE
         ST    R1,F@RECBUF        SAVE ADDRESS OF STORAGE
         SPACE
OPEN320  DS    0H            -- READY TO GENERATE RPL --
         LA    R2,FWARPL          -> TO WHERE RPL WILL BE BUILT
         CLC   =CL4'KSDS',0(R4)   KSDS?
         JE    OPEN400                                             @PJF
         CLC   =CL4'RRDS',0(R4)   RRDS?
         JE    OPEN410                                             @PJF
         CLC   =CL4'ESDS',0(R4)   ESDS?
         JE    OPEN420                                             @PJF
         EJECT
OPEN400  DS    0H                        -- KSDS --
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=FWARPLL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),         X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         JZ    OPEN500            YES, CONTINUE                    @PJF
         J     OPEN910            NO, DO ERROR HANDLING            @PJF
         SPACE
OPEN410  DS    0H                        -- RRDS --
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=FWARPLL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),         X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         JZ    OPEN500            YES, CONTINUE                    @PJF
         J     OPEN910            NO, DO ERROR HANDLING            @PJF
         SPACE
OPEN420  DS    0H                        -- ESDS --
         OI    F@RPLFL,F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=FWARPLL,OPTCD=(ADR,ARD,SEQ,FWD,KEQ,FKS),         X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         JZ    OPEN500            YES, CONTINUE                    @PJF
         J     OPEN910            NO, DO ERROR HANDLING            @PJF
         EJECT
OPEN500  DS    0H
         XC    IEANTTOK,IEANTTOK  CLEAR OUT TOKEN AREA
         ST    R7,IEANTTOK        SAVE -> TO FILE WORK AREA
         MVC   IEANTPOP,=AL4(IEANT_NOPERSIST)
*
* CREATE A NAME / TOKEN SO WE CAN FIND THE FILE WORK AREA NEXT TIME
* RXVSAM IS CALLED. REL 2.2: BUMP THRU CONTROL BLOCKS TO FIND IEANTCR.
*
         L     R15,X'10'
         L     R15,X'220'(R15,0)
         L     R15,X'14'(R15,0)
         L     R15,X'04'(R15,0)
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTPOP,IEANTRC),     X
               LINKINST=BASR,                                      @PJFX
               MF=(E,IEANTLST)
         SPACE
         LTR   R15,R15
         JZ    OPEN999            IF CREATE SUCCEEDED, ALL DONE    @PJF
         SPACE
         NTERROR REQ=CREATE,SYM=OPEN500,GOTO=OPEN999
         SPACE 3
OPEN900  DS    0H      -- GENERAL ERROR GENERATING THE ACB --
         MVC   VSAMELAB,=CL8'OPEN900'
         J     OPEN920                                             @PJF
         SPACE
OPEN910  DS    0H      -- GENERAL ERROR GENERATING THE RPL --
         MVC   VSAMELAB,=CL8'OPEN910'  SET LABEL & FALL THRU
         SPACE
OPEN920  DS    0H
         MVC   VSAMEREA,=CL2'00'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BRAS  R14,GETREG0        CHECK FOR REASON CODE IN R0
         SPACE
OPEN990  DS    0H
         SETMSG MSG=M$BADOPN      SET BAD RESULT CODE & FALL-THRU
         SPACE
OPEN999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
CLOS000  DS    0H
         ST    R14,RETURNTO       SAVE RETURN POINT
         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         JZ    CLOS100            FILE IS OPEN                     @PJF
         SPACE
         CH    R15,=AL2(IEANT_NOT_FOUND) FOR ANYTHING OTHER THAN "NOT
         JNE   CLOS050            FOUND" GENERATE A NAME / TOKEN ER@PJF
         SPACE
         SETMSG MSG=M$CLOSAC      ASSUME FILE ISN'T OPEN
         J     CLOS999                                             @PJF
         SPACE
CLOS050  DS    0H
         NTERROR REQ=RETRIEVE,SYM=CLOS000,GOTO=CLOS999
         SPACE
CLOS100  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         OC    FWAACB,FWAACB      ACB AREA SHOULD BE NON-ZERO
         JNZ   CLOS150            IF IT IS, CONTINUE               @PJF
         SPACE
         SETMSG MSG=M$CLOSAC      IF ACB IS ZERO, ASSUME FILE ISN'T
         J     CLOS999            OPEN - GENERATE MESSAGE & EXIT   @PJF
         SPACE
CLOS150  DS    0H
         XC    CLOSE_PARMLIST,CLOSE_PARMLIST INIT AREA
         OI    CLOSE_PARMLIST,X'80'          HI-ORDER ON = 31 BIT FORM
         LA    R3,FWAACB                     STORE POINTER TO ACB
         ST    R3,CLOSE_PARMLIST+4           IN 2ND WORD OF LIST
         CLOSE MODE=31,MF=(E,CLOSE_PARMLIST)
         SPACE
         LTR   R15,R15            SUCCESSFUL?
         JZ    CLOS500            YES - GO DELETE ACB VARIABLE     @PJF
         SPACE
         MVC   VSAMELAB,=CL8'CLOS000'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         JZ    CLOS300            YES - GO PICK UP ERROR MESSAGE   @PJF
         EJECT
CLOS200  DS    0H
         MVC   VSAMELAB,=CL8'CLOS200'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         J     CLOS990            AND EXIT ROUTINE                 @PJF
         SPACE
CLOS300  DS    0H
         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE
         OI    VSAMEREA+3,X'F0'
         J     CLOS990                                             @PJF
         SPACE
CLOS500  DS    0H      -- CLEANUP STUFF --
         OC    F@RECBUF,F@RECBUF    DO WE HAVE A RECORD BUFFER?
         JZ    CLOS510              NO, JUST DO FWA CLEANUP        @PJF
         SPACE
         L     R2,F@BUFLEN          LENGTH OF RECORD BUFFER
         L     R3,F@RECBUF          ADDRESS OF RECORD BUFFER
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)    RELEASE REC BUFFER
         SPACE
CLOS510  DS    0H
         LA    R2,FWALEN            LENGTH OF FILE WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R7)    RELEASE FWA
         SPACE
         L     R15,X'10'            BUMP THRU STORAGE TO FIND
         L     R15,X'220'(R15,0)    IEANTDL STUB / POINTER
         L     R15,X'14'(R15,0)
         L     R15,X'0C'(R15,0)
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTRC),MF=(E,IEANTLST),   @PJFX
               LINKINST=BASR                                       @PJF
         SPACE
         LTR   R15,R15              IF NAME / TOKEN DELETE WAS OK
         JZ    CLOS999              ALL DONE                       @PJF
         SPACE
         NTERROR REQ=DELETE,SYM=CLOS510,GOTO=CLOS999
         SPACE
CLOS990  DS    0H
         SETMSG MSG=M$BADCLO      SET MESSAGE & FALL-THRU
         SPACE
CLOS999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
READ000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         JZ    READ010            READY TO GO                      @PJF
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=READ000,GOTO=READ999
         SPACE
READ010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OIN     FILE OPEN FOR INPUT?
         JO    READ020            YES                              @PJF
         SPACE
         SETMSG MSG=M$NOIN        NO, SET MESSAGE
         J     READ999            AND EXIT                         @PJF
         SPACE
READ020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE READ LOGIC, R4 -> FWARPL
*
         LA    R4,FWARPL
*
*  FOR ANY READ TYPE, IF THE FILE IS OPEN FOR OUTPUT, ALLOW FOR THE
*  POSSIBILITY OF UPDATE (ENSURE RPL IS SET UP TO ALLOW UPDATE)
*
         TM    F@OPENFL,F@OOUT    IS FILE OPEN FOR OUTPUT?
         JZ    READ040            NO, LET RPL STAND AS IS          @PJF
         SPACE
         TM    F@RPLFL,F@RUPD     ALREADY SET UP FOR UPDATE?
         JNZ   READ040            YES, NO CHANGE TO RPL NEEDED     @PJF
         SPACE
         MODCB RPL=(R4),OPTCD=(UPD),MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID MODCB WORK?
         JZ    READ030            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ020'
         MVC   VSAMEREA,=CL2'00'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BRAS  R14,GETREG0        CHECK FOR REASON CODE IN REGISTER 0
         SETMSG MSG=M$BADUPD
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ030  DS    0H
         OI    F@RPLFL,F@RUPD     RESET FLAG TO INDICATE UPDATE
         EJECT
READ040  DS    0H        -- BRANCH TABLE FOR READ REQUEST TYPE --
         CLC   =CL11'READGENERIC',0(R5)
         JE    READ100                                             @PJF
         CLC   =CL8'READNEXT',0(R5)
         JE    READ200                                             @PJF
         CLC   =CL8'READPREV',0(R5)
         JE    READ300                                             @PJF
         CLC   =CL8'READLAST',0(R5)
         JE    READ400                                             @PJF
         J     READ500                                             @PJF
         EJECT
READ100  DS    0H         -- GENERIC READ --
         TM    F@OPENFL,F@OKSDS   IS FILE A KSDS?
         JO    READ102            YES, GENERIC READ IS ALLOWED     @PJF
         SETMSG MSG=M$NOGEN       OTHERWISE, SET ERROR MESSAGE
         J     READ999            AND EXIT ROUTINE                 @PJF
         SPACE
READ102  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         JE    READ104            NO, DO ERROR STUFF               @PJF
         LTR   R3,R3              WAS ARG LENGTH ZERO?
         JZ    READ104            YES, DO ERROR STUFF              @PJF
         J     READ106            KEY IS OK, CONTINUE PROCESSING   @PJF
         SPACE
READ104  DS    0H
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ106  DS    0H
         TM    F@RPLFL,F@RDIR     IS RPL SET UP FOR DIRECT READ?
         JO    READ108            YES, GO SET UP GENERIC KEY       @PJF
         BRAS  R14,TODIR          CHANGE TO DIRECT READ
         LTR   R15,R15            IF R15 IS ZERO
         JZ    READ108            RESET WAS SUCCESSFUL             @PJF
         J     READ999            ELSE, EXIT IMMEDIATELY           @PJF
         SPACE
READ108  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUR ARGUMENT/KEY AREA
         ST    R3,F@ARGLEN        SAVE LENGTH OF ARGUMENT
         BCTR  R3,0               DECREMENT FOR EXECUTED MVC
         EX    R3,ARGMVC          COPY KEY TO OUR AREA
         TM    F@RPLFL,F@RFKS+F@RKEQ   RPL SET UP FOR FULL KEY?
         JZ    READ600            NO, ALREADY SET FOR GENERIC, GET @PJF
         SPACE
         L     R2,F@ARGLEN        ACTUAL LENGTH OF GENERIC KEY
         MODCB RPL=(R4),OPTCD=(KGE,GEN),KEYLEN=(R2),                   X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    READ110            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ102'      SET LABEL IN ERROR MSG
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
READ110  DS    0H
         NI    F@RPLFL,X'FF'-(F@RFKS+F@RKEQ)    RESET OUR FLAG BITS
         J     READ600            GO GET RECORD                    @PJF
         EJECT
READ200  DS    0H         -- READ NEXT RECORD --
*
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         JNE   READ202            YES, CONTINUE                    @PJF
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ202  DS    0H
         TM    F@RPLFL,F@RSEQ+F@RFWD  SET FOR SEQ / FWD ?
         JO    READ600            YES, READY TO GET RECORD         @PJF
         SPACE
         MODCB RPL=(R4),OPTCD=(SEQ,FWD),                               X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            IF MODCB WORKED (RPL IS RESET)
         JZ    READ204            RESET OUR FLAG AND GO GET RECORD @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ204'   ELSE, SET ERROR MSG
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
READ204  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RFWD     RESET FLAG
         NI    F@RPLFL,X'FF'-F@RDIR
         J     READ600            GO GET RECORD                    @PJF
         EJECT
READ300  DS    0H         -- READ PREVIOUS RECORD --
*
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         JNE   READ302            YES, CONTINUE                    @PJF
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ302  DS    0H
         CLI   F@POINT,F@POINTY   HAS FILE POSITIONING BEEN DONE?
         JE    READ304            YES, CONTINUE                    @PJF
         SPACE
         SETMSG MSG=M$NOPOS       SET MESSAGE - NO PREVIOUS "STARTBWD"
         J     READ999                                             @PJF
         SPACE
READ304  DS    0H
         TM    F@RPLFL,F@RSEQ     SET FOR SEQUENTIAL ACCESS?
         JZ    READ306            NO, NEED TO ISSUE THE MODCB      @PJF
         TM    F@RPLFL,F@RFWD     SET UP FOR FORWARD PROCESSING?
         JZ    READ600            NO, CAN PROCEED DIRECTLY TO GET R@PJF
         SPACE
READ306  DS    0H
         MODCB RPL=(R4),OPTCD=(SEQ,BWD),                               X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            IF MODCB WORKED
         JZ    READ308            RESET OUR FLAG AND GO GET RECORD @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ306'   ELSE, SET ERROR MSG
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
READ308  DS    0H
         NI    F@RPLFL,X'FF'-(F@RFWD+F@RDIR)  NOW BACKWARD & NOT DIR
         OI    F@RPLFL,F@RSEQ           IS NOW SEQUENTIAL PROCESSING
         J     READ600            GO GET RECORD                    @PJF
         EJECT
READ400  DS    0H           -- READ LAST RECORD --
*
*  NOTE: THE NORMAL "GET" PROCESSING (AT LABEL READ600) IS NOT DONE
*        FOR THIS REQUEST SINCE THE RPL NEEDS TO BE SWITCHED BACK TO
*        ARD (USER'S ARGUMENT GOVERNS REQUEST) AFTER THE GET IS DONE.
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         JNE   READ402            YES, CONTINUE                    @PJF
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ402  DS    0H
         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?
         JO    READ404            YES, CONTINUE                    @PJF
         SPACE
         BRAS  R14,TODIR          NO, CHANGE TO DIRECT PROCESSING
         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL
         JZ    READ404                                             @PJF
         J     READ999            ELSE, JUST GIVE UP               @PJF
         SPACE
READ404  DS    0H
         MODCB RPL=(R4),OPTCD=(BWD,LRD),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    READ406            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ404'      NO, SET ERROR MESSAGE LABEL
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
READ406  DS    0H
         NI    F@RPLFL,X'FF'-F@RFWD   RESET OUR FLAG
         GET   RPL=(R4)
         SPACE
         LTR   R15,R15            SUCCESSFUL GET?
         JZ    READ408                                             @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ406'
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
READ408  DS    0H
         MODCB RPL=(R4),OPTCD=(ARD),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    READ800            YES, GO SET RECORD AS A REXX VARI@PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ408'      NO, SET ERROR MESSAGE LABEL
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         EJECT
READ500  DS    0H           -- DIRECT READ --
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         JE    READ502            NO, DO ERROR STUFF               @PJF
         LTR   R3,R3              WAS KEY LENGTH ZERO?
         JZ    READ502            YES, DO ERROR STUFF              @PJF
         J     READ504            KEY ARGUMENT OK, CONTINUE        @PJF
         SPACE
READ502  DS    0H
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ504  DS    0H
         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?
         JO    READ506            YES, CONTINUE                    @PJF
         SPACE
         BRAS  R14,TODIR          NO, GO CHANGE TO DIRECT PROCESSING
         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL
         JZ    READ506                                             @PJF
         J     READ999            OTHERWISE, QUIT                  @PJF
         SPACE
READ506  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR KEY AREA
         ST    R3,F@ARGLEN        SAVE KEY (ARGUMENT) LENGTH
         BCTR  R3,0               DECR LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY KEY
         TM    F@RPLFL,F@RFKS+F@RKEY   SET UP FOR FULL/EQUAL KEY?
         JO    READ510            YES, CHECK FOR DATASET TYPE      @PJF
         SPACE
         MODCB RPL=(R4),OPTCD=(KEQ,FKS),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    READ508            YES, RESET OUR FLAG & GET RECORD @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ506'   NO, SET ERROR MESSAGE LABEL
         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
READ508  DS    0H
         OI    F@RPLFL,F@RFKS+F@RKEQ   RESET OUR FLAG BITS
         SPACE
READ510  DS    0H
         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS
         JO    READ600            READY TO GET RECORD              @PJF
         SPACE
         BRAS  R14,CONVKEY        ELSE, CONVERT "KEY"
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         JNZ   READ999            ELSE, FALL-THRU TO READ600       @PJF
         EJECT
READ600  DS    0H   -- PERFORM GET MACRO & CHECK RESULT --
         GET   RPL=(R4)
         SPACE
         LTR   R15,R15            SUCCESSFUL GET?
         JZ    READ800            YES, SET RECORD AS A REXX VARIABL@PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ600'
         BRAS  R14,GETFDBK        GO GET FEEDBACK WORD
         SPACE
         CLC   VSAMEREA,FDBKNF    NOT FOUND?
         JNE   READ602            NO, TRY NEXT POSSIBILITY         @PJF
         SETMSG MSG=M$NOTFND      YES, SET MESSAGE
         J     READ999            AND CONSIDER READ "SUCCESSFUL"   @PJF
         SPACE
READ602  DS    0H
         CLC   VSAMEREA,FDBKEOF   END OF FILE
         JNE   READ604            NO, MUST BE SOME HOSEUP          @PJF
         SETMSG MSG=M$EOF         YES, SET MESSAGE
         J     READ999            AND CONSIDER READ "SUCCESSFUL"   @PJF
         SPACE
READ604  DS    0H
         SETMSG MSG=M$BADFUN      READ FAILED
         J     READ999            EXIT ROUTINE                     @PJF
         EJECT
READ800  DS    0H      -- RECORD OBTAINED, SET REXX VARIABLE --
         LA    R2,FULLWRK1
         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(RECLEN),           X
               MF=(G,SHOWCB_PARMLIST)
         LTR   R15,R15            SHOWCB WORKED?
         JZ    READ802            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'READ800'
         CVD   R15,DBLWRK         SET R.C. FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE FROM SHOWCB
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SETMSG MSG=M$NORLEN
         J     READ999                                             @PJF
         SPACE
READ802  DS    0H
         LA    R8,ARGTABLE_NEXT   GET LAST ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS RECORD VARIABLE NAME SUPPLIED?
         JNE   READ804            YES, GO SET VARIABLE             @PJF
         SPACE
         LA    R2,RECVARDF        NO, USE OUR DEFAULT
         LA    R3,L'RECVARDF
         SPACE
READ804  DS    0H
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         STM   R2,R3,SHVNAMA      STORE -> & LENGTH OF VARIABLE NAME
         MVC   SHVVALL,FULLWRK1   LENGTH OF RECORD AREA
         MVC   SHVVALA,F@RECBUF   ADDRESS OF RECORD AREA
         MVI   SHVCODE,SHVSTORE   NEED TO STORE THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF REXX VARIABLE ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX
               LINKINST=BASR                                       @PJF
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF    CHECK ERROR BITS
         JZ    READ999            IF VAR STORED SUCCESSFULLY, DONE @PJF
         SPACE
         SETMSG MSG=M$NOREC       SET ERROR MESSAGE
         J     READ999            EXIT ROUTINE                     @PJF
         SPACE
READ990  DS    0H     -- GENERAL ERROR LOGIC FOR MODCB FAILURE --
         BRAS  R14,GETREG0        GET REASON CODE
         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT
         SPACE
READ999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
STAR000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         JZ    STAR010            READY TO GO                      @PJF
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=STAR000,GOTO=STAR999
         SPACE
STAR010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         SPACE
STAR020  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR     WAS KEY SUPPLIED?
         C     R2,=X'FFFFFFFF'
         JE    STAR030            NO, DO ERROR STUFF               @PJF
         LTR   R3,R3              WAS IT'S LENGTH ZERO?
         JZ    STAR030            YES, DO ERROR STUFF              @PJF
         J     STAR040            KEY WAS OK, CONTINUE             @PJF
         SPACE
STAR030  DS    0H
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         J     STAR999            AND EXIT ROUTINE                 @PJF
         SPACE
STAR040  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUT ARGUMENT AREA
         ST    R3,F@ARGLEN        SAVE KEY LENGTH
         BCTR  R3,0               DECREMENT FOR EXECUTE
         EX    R3,ARGMVC          COPY KEY
         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS
         JO    STAR050            GO CHECK REQUEST                 @PJF
         SPACE
         BRAS  R14,CONVKEY        ELSE, CONVERT "KEY"
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         JNZ   STAR999            ELSE, FALL-THRU TO STAR050       @PJF
         EJECT
STAR050  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> FWARPL
*
         LA    R4,FWARPL
         CLC   =CL8'STARTFWD',0(R5)
         JE    STAR100                                             @PJF
         CLC   =CL8'STARTBWD',0(R5)
         JE    STAR200                                             @PJF
         SPACE
         SETMSG MSG=M$BADARG
         J     STAR999                                             @PJF
         SPACE
STAR100  DS    0H           -- POSITION FOR FORWARD READING --
         TM    F@RPLFL,F@RSEQ+F@RFWD    SET FOR SEQUENTIAL/FWD?
         JNO   STAR102            NO, NEED TO ISSUE MODCB          @PJF
         TM    F@RPLFL,F@RKEQ+F@RFKS    SET FOR KEY = / FULL KEY?
         JNZ   STAR102            YES, NEED TO ISSUE MODCB         @PJF
         J     STAR600            READY TO ISSUE POINT MACRO       @PJF
         SPACE
STAR102  DS    0H
         L     R2,F@ARGLEN        ARGUMENT (KEY LENGTH)
         MODCB RPL=(R4),OPTCD=(SEQ,FWD,KGE,GEN),KEYLEN=(R2),           X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    STAR104            YES, RESET OUR FLAGS & DO POINT  @PJF
         SPACE
         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL
         BRAS  R14,GETREG0        OBTAIN REASON CODE
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         J     STAR999                                             @PJF
         SPACE
STAR104  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RFWD     SET OUR FLAGS
         NI    F@RPLFL,X'FF'-(F@RDIR+F@RKEQ+F@RFKS)
         J     STAR600            READY TO ISSUE POINT MACRO       @PJF
         EJECT
STAR200  DS    0H      -- POSITION FOR BACKWARD READING --
         TM    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS  SEQ / KEY = / FULL KEY?
         JNO   STAR202            NO, NEED TO ISSUE MODCB          @PJF
         TM    F@RPLFL,F@RFWD     FORWARD?
         JO    STAR202            YES, NEED TO ISSUE MODCB         @PJF
         J     STAR600            READY TO ISSUE POINT MACRO       @PJF
         SPACE
STAR202  DS    0H
         MODCB RPL=(R4),OPTCD=(SEQ,BWD,KEQ,FKS),                       X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         JZ    STAR204            YES, RESET OUR FLAGS & DO POINT  @PJF
         SPACE
         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL
         BRAS  R14,GETREG0        OBTAIN REASON CODE
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         J     STAR999                                             @PJF
         SPACE
STAR204  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS     SET OUR FLAGS
         NI    F@RPLFL,X'FF'-(F@RDIR+F@RFWD)
         J     STAR600            READY TO ISSUE POINT MACRO       @PJF
         EJECT
STAR600  DS    0H     -- ISSUE POINT FOR FILE POSITIONING --
         POINT RPL=(R4)
         SPACE
         LTR   R15,R15            POINT SUCCESSFUL?
         JZ    STAR900            YES, ALL DONE                    @PJF
         SPACE
         MVI   F@POINT,F@POINTN   NO FILE POSITIONING
         BRAS  R14,GETFDBK        GO GET FEEDBACK WORD
         SPACE
         CLC   VSAMEREA,FDBKEOF   WAS IT AN "END OF FILE"?
         JNE   STAR602            NO, TRY NEXT POSSIBILITY         @PJF
         SPACE
         SETMSG MSG=M$EOF         YES, SET MESSAGE
         J      STAR999           CONSIDER START "SUCCESSFUL"      @PJF
         SPACE
STAR602  DS    0H
         CLC   VSAMEREA,FDBKNF    WAS IT A "NOT FOUND"?
         JNE   STAR604            NO, MUST BE SOME GENUINE HOSEUP  @PJF
         SPACE
         SETMSG MSG=M$BWDNF       YES, SET MESSAGE
         J      STAR999           CONSIDER START "SUCCESSFUL"      @PJF
         SPACE
STAR604  DS    0H
         MVC   VSAMELAB,=CL8'STAR604'   POINT GOT AN UNEXPECTED ERROR
         SETMSG MSG=M$BADFUN      SET MESSAGE
         J     STAR999            EXIT                             @PJF
         SPACE
STAR900  DS    0H
         MVI   F@POINT,F@POINTY   FILE POSITIONING HAS BEEN DONE
         SPACE 2
STAR999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
WRIT000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         JZ    WRIT010            READY TO GO                      @PJF
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=WRIT000,GOTO=WRIT999
         SPACE
WRIT010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         JO    WRIT020            YES                              @PJF
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         J     WRIT999            AND EXIT                         @PJF
         SPACE
WRIT020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> FWARPL
*
         LA    R4,FWARPL
         TM    F@RPLFL,F@RUPD     SET FOR UPDATE?
         JZ    WRIT100            NO, READY TO DO RECORD STUFF     @PJF
         SPACE
         MODCB RPL=(R4),OPTCD=(NUP),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         JZ    WRIT030            YES, RESET OUR FLAGS, ETC.       @PJF
         SPACE
         MVC   VSAMELAB,=CL8'WRIT020'
         J     WRIT990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
WRIT030  DS    0H
         NI    F@RPLFL,X'FF'-F@RUPD     RESET FLAG & FALL-THRU
         EJECT
WRIT100  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?
         JNE   WRIT110            YES, CONTINUE                    @PJF
         SPACE
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         J     WRIT999            EXIT ROUTINE                     @PJF
         SPACE
WRIT110  DS    0H
         LTR   R3,R3              IF ARG IS NONNULL,
         JNZ   WRIT130            COPY "KEY" INTO OUR AREA         @PJF
         SPACE
         MODCB RPL=(R4),OPTCD=(SEQ),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         JZ    WRIT120            YES, RESET OUR FLAGS, ETC.       @PJF
         SPACE
         MVC   VSAMELAB,=CL8'WRIT110'
         J     WRIT990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
WRIT120  DS    0H
         OI    F@RPLFL,F@RSEQ     NOW SET FOR SEQUENTIAL ACCESS
         NI    F@RPLFL,X'FF'-F@RDIR   NO LONGER SET FOR DIRECT
         J     WRIT140            SKIP OVER KEY COPY               @PJF
         SPACE
WRIT130  DS    0H
         XC    F@RPLARG,F@RPLARG  ELSE CLEAR OUT OUR COPY OF THE "KEY"
         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER
         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY ARGUMENT TO OUR "KEY" AREA
         TM    F@RPLFL,F@RDIR     SET FOR DIRECT ACCESS?
         JO    WRIT140            YES, CONTINUE                    @PJF
         SPACE
         BRAS  R14,TODIR          NO, SWITCH TO DIRECT
         LTR   R15,R15            IF THAT FAILED
         JNZ   WRIT999            JUST GIVE UP                     @PJF
         SPACE
WRIT140  DS    0H
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH
         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?
         JNE   WRIT150            NO, PICK UP REC AREA VARIABLE NAM@PJF
         SPACE
         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC
         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH
         EJECT
WRIT150  DS    0H
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME
         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE
         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX
               LINKINST=BASR                                       @PJF
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         JZ    WRIT160            DID WE GET THE VARIABLE OK?      @PJF
         SPACE
         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT
         J     WRIT999                                             @PJF
         SPACE
WRIT160  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -
         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?
         JZ    WRIT170            NO, READY TO PUT RECORD          @PJF
         SPACE
         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE
         J     WRIT999            AND EXIT ROUTINE                 @PJF
         SPACE
WRIT170  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --
         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)
         MODCB RPL=(R4),RECLEN=(R2),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB WORKED?
         JZ    WRIT180            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'WRIT170'   NO, SET LABEL IN ERROR MSG
         J     WRIT990            DO GENERAL MODCB FAILURE LOGIC   @PJF
         SPACE
WRIT180  DS    0H
         TM    F@OPENFL,F@ORRDS   IS FILE AN RRDS?
         JZ    WRIT190            NO, READY TO PUT RECORD          @PJF
         TM    F@RPLFL,F@RSEQ     SEQUENTIAL ACCESS?
         JO    WRIT190            YES, NO KEY TO CONVERT           @PJF
         SPACE
         BRAS  R14,CONVKEY        ELSE, CONVERT KEY
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         JNZ   WRIT999            ELSE, FALL-THRU & PUT RECORD     @PJF
         EJECT
WRIT190  DS    0H
         PUT   RPL=(R4)           WRITE THE RECORD
         LTR   R15,R15            SUCCESSFUL?
         JZ    WRIT999            ALL DONE                         @PJF
         SPACE
         BRAS  R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE
         JNE   WRIT200            NO, TRY NEXT POSSIBILITY         @PJF
         SETMSG MSG=M$DUPL        YES, SET MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE
WRIT200  DS    0H
         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?
         JNE   WRIT210            NO, TRY NEXT POSSIBILITY         @PJF
         SETMSG MSG=M$BADRL       YES, SET MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE
WRIT210  DS    0H
         MVC   VSAMELAB,=CL8'WRIT210'   SET LABEL IN ERROR MSG
         SETMSG MSG=M$BADFUN      BAD FUNCTION
         J     WRIT999            EXIT ROUTINE                     @PJF
         SPACE
WRIT990  DS    0H        -- GENERAL LOGIC FOR MODCB FAILURE --
         BRAS  R14,GETREG0        OBTAIN FEEDBACK
         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT
         SPACE
WRIT999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
REWR000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         JZ    REWR010            READY TO GO                      @PJF
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=REWR000,GOTO=REWR999
         SPACE
REWR010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         JO    REWR020            YES                              @PJF
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         J     REWR999            AND EXIT                         @PJF
         SPACE
REWR020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE REWRITE LOGIC, R4 -> FWARPL
* AND R6 -> SHARED VARIABLE BLOCK
*
         LA    R4,FWARPL
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?
         JE    REWR030            NO, DO ERROR STUFF               @PJF
         LTR   R3,R3              IS KEY ARGUMENT LENGTH ZERO?
         JZ    REWR040            YES, ENSURE IT'S AN ESDS         @PJF
         J     REWR050            KEY IS OK, CONTINUE              @PJF
         SPACE
REWR030  DS    0H
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         EJECT
REWR040  DS    0H        -- ZERO LENGTH ONLY ALLOWED FOR AN ESDS --
         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?
         JO    REWR060            YES - IT'S OK - SKIP KEY STUFF   @PJF
         SPACE
         SETMSG MSG=M$KEYZER      SET ZERO KEY LENGTH MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE
REWR050  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUT OUR COPY OF THE "KEY"
         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER
         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY ARGUMENT TO OUR "KEY" AREA
         SPACE
REWR060  DS    0H        -- CHECK FOR RECORD VARIABLE NAME --
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH
         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?
         JNE   REWR070            NO, PICK UP REC AREA VARIABLE NAM@PJF
         SPACE
         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC
         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH
         SPACE
REWR070  DS    0H
         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME
         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE
         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX
               LINKINST=BASR                                       @PJF
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         JZ    REWR080            DID WE GET THE VARIABLE OK?      @PJF
         SPACE
         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT
         J     REWR999                                             @PJF
         SPACE
REWR080  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -
         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?
         JZ    REWR100            NO, READY TO PUT RECORD          @PJF
         SPACE
         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE
         J     REWR999            AND EXIT ROUTINE                 @PJF
         EJECT
REWR100  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --
         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)
         MODCB RPL=(R4),RECLEN=(R2),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB WORKED?
         JZ    REWR110            YES, CONTINUE                    @PJF
         SPACE
         MVC   VSAMELAB,=CL8'REWR100'   NO, SET LABEL IN ERROR MSG
         BRAS  R14,GETREG0        GET FEEDBACK FROM REGISTER 0
         SETMSG MSG=M$BADFUN      INDICATE FAILURE
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE
REWR110  DS    0H
         PUT   RPL=(R4)           WRITE THE RECORD
         LTR   R15,R15            SUCCESSFUL?
         JZ    REWR999            CONTINUE                         @PJF
         SPACE
         BRAS  R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE
         JNE   REWR120            NO, TRY NEXT POSSIBILITY         @PJF
         SETMSG MSG=M$DUPL        YES, SET MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE
REWR120  DS    0H
         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?
         JNE   REWR130            NO, TRY NEXT POSSIBILITY         @PJF
         SETMSG MSG=M$BADRL       YES, SET MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE
REWR130  DS    0H
         MVC   VSAMELAB,=CL8'REWR130'   SET LABEL IN ERROR MSG
         SETMSG MSG=M$BADFUN      BAD FUNCTION
         J     REWR999            EXIT ROUTINE                     @PJF
         SPACE 2
REWR999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
DELE000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         JZ    DELE010            READY TO GO                      @PJF
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=DELE000,GOTO=DELE999
         SPACE
DELE010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         JO    DELE020            YES                              @PJF
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         J     DELE999            AND EXIT                         @PJF
         SPACE
DELE020  DS    0H
         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?
         JZ    DELE030            NO, OK TO CONTINUE               @PJF
         SPACE
         SETMSG MSG=M$NOESDS      YES, IT IS - THIS FUNCTION NOT
         J     REWR999            ALLOWED FOR AN ESDS, SET MSG&EXIT@PJF
         SPACE
DELE030  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IF KEY ARGUMENT EXISTS, DO ERASE
         JNE   DELE100            (RECORD AREA ARGUMENT IS IGNORED)@PJF
         SPACE
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         J     REWR999            EXIT ROUTINE                     @PJF
         EJECT
DELE100  DS    0H
         LA    R4,FWARPL
         ERASE RPL=(R4)           ERASE THE RECORD
         LTR   R15,R15            IF ERASE WAS SUCCESSFUL
         JZ    DELE999            EXIT ROUTINE                     @PJF
         SPACE
         MVC   VSAMELAB,=CL8'DELE100'   ERASE FAILED, SET LABEL
         BRAS  R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKNOGE  ERROR WAS "NO PREVIOUS GET"?
         JNE   DELE110            NO, INDICATE GEN FUNCTION FAILURE@PJF
         SPACE
         SETMSG MSG=M$NOGET       SET NO PREVIOUS GET MESSAGE
         J     DELE999            EXIT ROUTINE                     @PJF
         SPACE
DELE110  DS    0H
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         SPACE 2
DELE999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
TODIR    DS    0H         -- CHANGE RPL TO DIRECT READ --
*
* ANY NON-ZERO VALUE IN R15 UPON EXIT INDICATES TO THE CALLER THAT
* THIS ROUTINE DETECTED A PROBLEM, AND FURTHER PROCESSING IS PROBABLY
* NOT A GOOD IDEA
*
* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         SR    R15,R15            CLEAR R15
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         JO    TODIR100           YES, MODIFY ONLY PROCESSING TYPE @PJF
         SPACE
         MODCB RPL=(R4),OPTCD=(DIR,NSP),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         JZ    TODIR200           YES, RESET OUR FLAGS             @PJF
         SPACE
         MVC   VSAMELAB,=CL8'TODIR'
         J     TODIR900           DO REST OF ERROR PROCESSING      @PJF
         SPACE
TODIR100 DS    0H
         MODCB RPL=(R4),OPTCD=(DIR),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         JZ    TODIR200           YES, GO RESET OUR FLAG           @PJF
         SPACE
         MVC   VSAMELAB,=CL8'TODIR200'
         J     TODIR900           DO REST OF ERROR PROCESSING      @PJF
         SPACE
TODIR200 DS    0H
         OI    F@RPLFL,F@RDIR     RESET OUR FLAG - DIRECT PROCESSING
         NI    F@RPLFL,X'FF'-F@RSEQ       TURN OFF SEQUENTIAL FLAG
         J     TODIR999           ALL DONE, EXIT ROUTINE           @PJF
         SPACE
TODIR900 DS    0H         -- ERROR MODIFYING A CONTROL BLOCK --
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BRAS  R14,GETREG0        GET REASON CODE FROM REGISTER 0
         SETMSG MSG=M$BADDSW      SET BAD RESULT CODE & FALL-THRU
         SPACE
TODIR999 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
RTRVTOK0 DS    0H
*
*  RETRIEVES THE NAME / TOKEN PAIR.  CALLER MUST CHECK FOR ERRORS -
*  R15 IS LEFT INTACT. REL 2.2: BUMP THRU STORAGE TO FIND IEANTRT
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         L     R15,X'10'
         L     R15,X'220'(R15,0)
         L     R15,X'14'(R15,0)
         L     R15,X'08'(R15,0)
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTRC),              X
               LINKINST=BASR,                                      @PJFX
               MF=(E,IEANTLST)
         SPACE
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
CONVKEY  DS    0H    -- CONVERT AN RRN KEY TO BINARY --
*
*  A NON-ZERO VALUE IN R15 INDICATES THAT THE ARGUMENT (KEY) WAS
*  NOT NUMERIC.  THIS ROUTINE SETS THE ERROR MESSAGE.
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         SR    R15,R15            SET ROUTINE RETURN CODE TO ZERO
         L     R14,F@ARGLEN       GET KEY LENGTH
         BCTR  R14,0              DECREMENT FOR EXECUTE
         EX    R14,ARGTRT         TEST TO ENSURE IT'S NUMERIC
         JZ    CONVK100           IF IT WAS, CONTINUE              @PJF
         SPACE
         SETMSG MSG=M$NONNUM      ELSE, SET MSG (WHICH PUTS A NON-ZERO
         J     CONVK999           VALUE IN R15 ALSO), AND EXIT ROUT@PJF
         SPACE
CONVK100 DS    0H
         EX    R14,ARGPACK        PACK KEY
         CVB   R14,DBLWRK         CONVERT TO BINARY
         ST    R14,F@RPLARG       REPLACE ARGUMENT, THEN EXIT
         SPACE
CONVK999 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              RETURN TO CALLER
         EJECT
GETFDBK  DS    0H          -- GET FDBK / SET REASON CODE --
*
* This routine will issue a SHOWCB to obtain the feedback fullword
* so the reason code can be added to the error message.  This routine
* assumes that R15 still contains the VSAM return code (probably 8).
* The caller of this routine is responsible for setting the value of
* VSAMELAB before the call and issuing the SETMSG macro upon return
* from the routine.
*
* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(FDBK),             X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         JZ    GETFDBK1           YES - GO PICK UP ERROR MESSAGE   @PJF
         SPACE
         MVC   VSAMELAB,=CL8'GETFDBK'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         J     GETFDBK9           EXIT SUBROUTINE                  @PJF
         SPACE
GETFDBK1 DS    0H
*
*  TO CONSIDER:  SAVE FDBK WORD IN A DISPLAYABLE FORMAT SOMEWHERE
*
         SR    R14,R14
         IC    R14,BYTEWRK2       LAST BYTE OF FEEDBACK WORD
         CVD   R14,DBLWRK         IS THE REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SPACE
GETFDBK9 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
GETREG0  DS    0H
*
* Put reason code into VSAMEMSG - this routine assumes the return code
* from a VSAM SHOWCB, MODCB, etc., has been left intact in R15.  No
* registers are altered by this routine, can be called from anywhere
*
         CH    R15,=H'4'          REASON CODE IS ONLY IN R0 WHEN THE
         JNE   GETREG0X           VSAM R.C. IS 4                   @PJF
         SPACE
         CVD   R0,DBLWRK          PUT REASON CODE IN VSAM ERROR MESSAGE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SPACE
GETREG0X DS    0H
         BSM   0,R14              RETURN TO CALLER
         SPACE
         TITLE 'RXVSAM - L T O R G'
CONSTANT DS    0D                 BASE FOR LTORG + CONSTANTS
         LTORG
         TITLE 'RXVSAM - Constants'
         DS    0D
NUMTAB   DC    256X'FF'           TRT TABLE FOR NUMERIC CLASS TEST
         ORG   NUMTAB+C'0'
         DC    10X'00'
         ORG
*                                                                  @PJF
* MOVEDDNM - EXecuted MVC to copy the DDNAME argument to local stg.@PJF
*                                                                  @PJF
         SPACE ,                                                   @PJF
MOVEDDNM MVC   DDNAME(0),0(R3)    EXECUTED INSTRUCTION             @PJF
         SPACE 3                                                   @PJF
*                                                                  @PJF
* ARGMVC - EXecuted MVC to copy argument (key / RRN / RBA) to the  @PJF
*          area where the RPL expects to find it.  R2 must point   @PJF
*          to the argument source.                                 @PJF
*                                                                  @PJF
         SPACE ,                                                   @PJF
ARGMVC   MVC   F@RPLARG(0),0(R2)  EXECUTED INSTRUCTION             @PJF
         SPACE 3                                                   @PJF
*                                                                  @PJF
* ARGTRT - EXecuted TRT to check for numeric bytes in an RRN / RBA @PJF
*          key.                                                    @PJF
*                                                                  @PJF
         SPACE ,                                                   @PJF
ARGTRT   TRT   F@RPLARG(0),NUMTAB EXECUTED INSTRUCTION             @PJF
         SPACE 3                                                   @PJF
*                                                                  @PJF
* ARGPACK - EXecuted PACK for converting RRN / RBA key to packed   @PJF
*           decimal.                                               @PJF
*                                                                  @PJF
         SPACE ,                                                   @PJF
ARGPACK  PACK  DBLWRK,F@RPLARG(0) EXECUTED INSTRUCTION             @PJF
*
* COMMON FDBK REASON CODES IN CHARACTER (DECIMAL) FORMAT
*
FDBKEOF  DC    CL4'0004'               END OF FILE
FDBKDUPL DC    CL4'0008'               DUPLICATE RECORD
FDBKSEQE DC    CL4'0012'               SEQUENCE ERROR
FDBKNF   DC    CL4'0016'               RECORD NOT FOUND
FDBKNOGE DC    CL4'0092'               PUT OR ERASE, NO PREVIOUS GET
FDBKBADL DC    CL4'0108'               BAD RECORD LENGTH
*
* MISCELLANEOUS CONSTANTS
*
USCORE   DC    8C'_'              UNDERSCORES CONSTANT
SPACES   DC    CL8' '             SPACES CONSTANT
IRXEXLIT DC    CL8'IRXEXCOM'      PROGRAM NAME CONSTANT
RXVSMSG@ DC    V(RXVSAMSG)        -> TO RXVSAMSG CSECT
VMSGVAR  DC    CL19'RXVSAM_VSAMERRORMSG'     VSAM ERR MSG VAR NAME
RMSGVAR  DC    CL16'RXVSAM_RETURNMSG'  RETURN MESSAGE VARIABLE NAME
RECVARDF DC    CL13'RXVSAM_RECORD'     DEFAULT RECORD VARIABLE NAME
         SPACE
VMSGINIT DS    0X
         DC    CL43'VSAM error, return code in register 15 was '
         DC    CL2'00'
         DC    CL18', reason code was '
         DC    CL4'0000'
         DC    CL23' (label in RXVSAM was: '
         DC    CL8' '
         DC    CL1')'
VMSGLEN  EQU   *-VMSGINIT
         SPACE
NTMSGINI DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE
         DC    CL44'NAME / TOKEN service error, register 15 was '
         DC    CL2'00'
         DC    CL14', request was '
         DC    CL8' '
         DC    CL23' (label in RXVSAM was: '
         DC    CL8' '
         DC    CL1')'
         SPACE
         TITLE 'RXVSAM - Local Work Area'
*
* This area is initialized to X'00'
*
LOCAL_WORKAREA DSECT
DBLWRK   DS    0D
FULLWRK1 DS    F
FULLWRK2 DS    0F
HALFWRK1 DS    H
HALFWRK2 DS    0H
BYTEWRK1 DS    X
BYTEWRK2 DS    X
         SPACE
         DS    0D                 ALIGN ON A DOUBLEWORD
IEANTNAM DS    0CL16              NAME FOR NAME / TOKEN PAIR
IEANTNA1 DS    CL8                 - 1ST PART (BASED ON JOB ID)
IEANTNA2 DS    CL8                 - 2ND PART (BASED ON FILE DD)
IEANTTOK DS    XL16               TOKEN FOR NAME / TOKEN PAIR
*        The 1st fullword of the token is a -> to this file's FWA
IEANTLVL DS    A                  LEVEL FOR IEANT SERVICE
IEANTPOP DS    A                  PERSIST OPTION FOR IEANT SERVICE
IEANTRC  DS    F                  RETURN CODE FROM IEANT SERVICE
IEANTLST DS    5F                 ADDR LIST FOR ABOVE 5 PARMS (CALL)
         SPACE
SAVEAREA DS    18F
         SPACE
EXCOPLST DS    4F                 PARM LIST AREA FOR IREXCOM CALL
GENCB_PARMLIST DS  20F            PARM LIST FOR GENCB MACRO
MODCB_PARMLIST DS  20F            PARM LIST FOR MODCB MACRO
SHOWCB_PARMLIST DS 20F            PARM LIST FOR SHOWCB MACRO
OPEN_PARMLIST  DS  2F             PARM LIST FOR OPEN MACRO
CLOSE_PARMLIST DS  2F             PARM LIST FOR CLOSE MACRO
         SPACE
MSG@     DC    F'0'               -> TO ERROR MSG TEXT
EFPL@    DC    F'0'               -> TO EFPL (SAVED AT FUNCTION ENTRY)
ENVB@    DC    F'0'               -> TO ENVB (SAVED AT ENTRY)      @ANZ
IRXEXCO@ DC    F'0'               -> IRXEXCOM ENTRY ADDRESS
RECBUF@  DC    F'0'               -> TO RECORD BUFFER AREA
RETURNTO DC    F'0'               R14 SAVE FOR OPEN/READ/WRIT/CLOS ETC
LVL1R14  DC    F'0'               R14 SAVE - LEVEL 1 SUBROUTINES
NAMTOKRC DC    F'0'               R15 (R.C.) FROM NAME / TOKEN SERVICES
TRACE@B  DC    F'0'               -> TO TRACE AREA
TRACE@C  DC    F'0'               -> TO "NEXT" SLOT IN TRACE AREA
TRACE@M  DC    F'0'               -> TO END OF TRACE AREA
MSGLEN   DC    H'0'               LENGTH OF RETURN MESSAGE (MSG@)
RECBUFL  DC    H'0'               LENGTH OF RECORD BUFFER (RECBUF@)
MYJOBID  DS    CL8                JOB ID (1ST CHAR OVERLAID WITH "X")
DDNAME   DS    CL8                SPACE PADDED DDNAME
         SPACE
VSAMEMSG DS    0X                 VSAM ERROR MESSAGE
         DS    CL43
VSAMER15 DS    CL2
         DS    CL18
VSAMEREA DS    CL4
         DS    CL23
VSAMELAB DS    CL8
         DS    CL1
VSAMELEN EQU   *-VSAMEMSG
         SPACE
NTMSG    DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE
         DS    CL44
NTMSGR15 DS    CL2
         DS    CL14
NTREQ    DS    CL8
         DS    CL23
NTLABEL  DS    CL8
         DS    CL1
NTMSGLEN EQU   *-NTMSG
         SPACE
         DS    0F
OURSHVBL DC  XL(SHVBLEN)'00'           OUR SHARED VARIABLE BLK STORAGE
         SPACE
LOCAL_WORKAREA_LENGTH EQU *-LOCAL_WORKAREA   TOTAL LENGTH OF AREA
         TITLE 'RXVSAM - File Work Area  '
FWABLOCK DSECT
*
* FWABLOCK - THERE WILL BE ONE OF THESE FOR EACH OPEN VSAM DATASET.
* The OPEN routine obtains the storage, and the CLOSE routine releases
* it.  NAME / TOKEN services are used to manage (keep track) of this
* block between invocations of RXVSAM.
*
FWA      DS    0F   --- BEGINNING OF FILE WORK AREA ---
FWAACB   DS    XL(LEN_ACB)        OUR COPY OF CURRENT ACB
FWAACBL  EQU   *-FWAACB           LENGTH OF AREA
         SPACE
FWARPL   DS    XL(LEN_RPL)        OUR COPY OF CURRENT RPL
FWARPLL  EQU   *-FWARPL           LENGTH OF AREA
         SPACE
FWAFLAGS DS    0F                 FLAGS
F@RECBUF DC    F'0'                - OUR RECORD BUFFER ADDRESS
F@BUFLEN DC    F'0'                - LENGTH OF OUR RECORD BUFFER
F@LRECL  DC    F'0'                - MAX RECORD LENGTH FOR THIS FILE
F@ARGLEN DC    F'0'                - LENGTH OF KEY (ARGUMENT)
F@OPENFL DC    X'0'                - ACB FLAGS
F@OIN    EQU   X'80'                 - OPEN FOR INPUT   | Both flags on
F@OOUT   EQU   X'40'                 - OPEN FOR OUTPUT  | if open I-O
F@OSEQ   EQU   X'20'                 - FILE SET FOR SEQUENTIAL ACCESS
F@ODIR   EQU   X'10'                 - FILE SET FOR DIRECT ACCESS
F@O###   EQU   X'08'                 - (UNUSED BIT SETTING)
F@OKSDS  EQU   X'04'                 - FILE IS A KSDS
F@ORRDS  EQU   X'02'                 - FILE IS AN RRDS
F@OESDS  EQU   X'01'                 - FILE IS AN ESDS
F@RPLFL  DC    X'0'                - RPL FLAGS
F@RKEY   EQU   X'80'                 - USE KEY (RRN) ARGS (OFF = ADR)
F@RARD   EQU   X'40'                 - USE USER'S ARGS (OFF = LRD)
F@RSEQ   EQU   X'20'                 - SEQUENTIAL ACCESS
F@RDIR   EQU   X'10'                 - DIRECT ACCESS (MAY ALSO SET NSP)
F@RUPD   EQU   X'08'                 - UPD (OFF = NUP {UNLESS F@RDIR})
F@RFWD   EQU   X'04'                 - FORWARD (OFF = BWD) PROCESSING
F@RKEQ   EQU   X'02'                 - EQUAL KEY (OFF = KGE)
F@RFKS   EQU   X'01'                 - FULL KEY SUPPLIED (OFF = GEN)
F@POINT  DS    X                  FILE POSITIONING IS SET
F@POINTN EQU   X'00'                - NO
F@POINTY EQU   X'FF'                - YES
         DS    X
F@RPLARG DC    XL255'00'          ARGUMENT (KEY) AREA FOR RPL
         SPACE
         DS    XL1
FWALEN   EQU   *-FWA              LENGTH OF FILE WORK AREA BLOCK
FWAEND   DS    0X                 END OF BLOCK MARKER
*
* End of FILE WORK AREA block
*
         TITLE 'RXVSAM - IRXEFPL Dsect'
         PRINT GEN
         IRXEFPL
         TITLE 'RXVSAM - IRXEVALB Dsect'
         IRXEVALB
         TITLE 'RXVSAM - IRXARGTB Dsect'
         IRXARGTB
         TITLE 'RXVSAM - IRXSHVB Dsect'
         IRXSHVB
         TITLE 'RXVSAM - IRXENVB Dsect'                            @ANZ
         IRXENVB                                                   @ANZ
         TITLE 'RXVSAM - IRXEXTE Dsect'                            @ANZ
         IRXEXTE                                                   @ANZ
         TITLE 'RXVSAM - MISC SYSTEM DESCTS'
         IAZJSAB DSECT=YES
         IHAASCB
         IHAASSB
         IHAPSA
         IKJTCB
         IHASTCB ,                                                 @PJF
         IFGRPL   DSECT=YES,AM=VSAM
LEN_RPL  EQU   *-IFGRPL
         IFGACB   DSECT=YES,AM=VSAM
LEN_ACB  EQU   *-IFGACB
         EJECT
 TITLE 'RXVSAMSG - Error Messages for RXVSAM'
         PRINT GEN
RXVSAMSG AMODE 31
RXVSAMSG RMODE ANY
RXVSAMSG GENMSGS GEN=CSECT
         END
